[{"content":"前段时间，我朋友入手了5090（可恶的有钱人），将淘汰下来的主机出手给了我，由于附带的卡是5070 12g，虽然说显存不够大，但是还是想要体验一下N卡的本地模型的乐趣，所以就接手了。于是，我面临了一个问题，我如何将我现有的archlinux配置克隆到新主机上。\n全盘克隆 or 配置文件克隆 现在我面临一个问题，我就是是选择全盘将系统克隆过去，还是只是克隆一些配置文件。前一种方案的好处即全盘克隆可以原封不动实现系统迁徙，并且立即能用；但是存在以下一系列问题，如会携带旧系统大量的垃圾文件，对于不同硬件适配可能产生冲突，就像把旧电脑的主板焊到新机箱使用，维护难度很大。后一种好处有可以在移植的时候思考哪些是我们迁移的时候必要的文件，最小化克隆，对于不同的硬件场景我们也可以很好的进行适配，比如说我们需要将现有的配置移植到arm平台的archlinux，同时不会携带一些旧文件，不适用的驱动等。前一种有如 dd↗ ， clonezilla↗ ， rsync↗ ；后一种我们选择使用 dotfiles↗ 。\n很显然，我们会选择dotfiles作为我们的克隆系统方案，尽管他麻烦一点:)。\n步骤 ","permalink":"http://localhost:12409/posts/2025_12_09-clone_your_archlinux/","summary":"\u003cp\u003e前段时间，我朋友入手了5090（可恶的有钱人），将淘汰下来的主机出手给了我，由于附带的卡是5070 12g，虽然说显存不够大，但是还是想要体验一下N卡的本地模型的乐趣，所以就接手了。于是，我面临了一个问题，我如何将我现有的archlinux配置克隆到新主机上。\u003c/p\u003e","title":"Clone_your_archlinux"},{"content":"我现在的博客部署在 github.io 上，一直想要在个人网站上搭建自己的博客以及部署一些有意思的项目，这次趁双十一购入了服务器与域名，这里做一个简单的记录。\n一台可用的VPS 你可以在任意VPS提供商上购买所需要的服务器，比如说我这边是用的是 RackNerd↗ ，正好赶上双11优惠，花费了70块弄了一个低配的KVM小机子，用作轻量级服务。1vCPU, 1G内存, 20G硬盘空间，3T/月的带宽，虽说配置比较低，但是很适合配置轻量级服务器与学习作用。\n反正就是权衡一下自己的需求，按照性能、稳定性、性价比来选择自己的服务器选型，大家可以自行去网上寻找关于各家VPS的测评。\n我这边购买了RackNerd的服务器遇到了很奇怪的问题。在登录验证邮件中的IP 地址和登录进控制台实际显示的IP 地址不一致，最后是控制台实际显示的IP 地址是正确地址，通过控制台显示的IP能够正常登录。\n一个可用的域名 你同样可以在任意的顶级域名提供商上购买你所中意的域名，我们一般选择.com后缀的域名，具体关于域名选择的讨论可以看 Ask HN: Which domain extension would you choose for your personal site?↗ 。\n我这里选择的是 SpaceShip↗ 上购买我的域名，在哪一家购买域名都可以，基本上就是看价格谁家便宜，我这里购买了 downmars.com 。\nDNS解析 DNS（Domain Name System）域名系统可以告诉网络你的域名关联再哪个服务器上面，我这边选择了 Cloudflare↗ 。它除了帮忙提供DNS解析之外，还能够提供安全流量代理、CDN解析等内容。\n我们再Cloudflare上添加需要管理的域名，选择免费套餐即可，在记录中添加：\nType: A, Name: @, Content: 你的IP地址 Type: CNAME, Name: www, Content: 你的域名\n这两个分别是将访问的域名联系上服务器的IP与将www自动跳转到主域名。 到此，我们设置服务器、域名与DNS解析部分的设置就已经基本完成了，接下来我们就可以在服务器上部署我的所需要的服务了。\n","permalink":"http://localhost:12409/posts/2025_11_16-build_a_personal_website/","summary":"\u003cp\u003e我现在的博客部署在\u003ca href=\"github.io\"\n   \n   \n   class=\"custom-link\"\u003e  \n   github.io\u003c/a\u003e\n上，一直想要在个人网站上搭建自己的博客以及部署一些有意思的项目，这次趁双十一购入了服务器与域名，这里做一个简单的记录。\u003c/p\u003e\n\u003ch2 id=\"一台可用的vps\"\u003e一台可用的VPS\u003c/h2\u003e\n\u003cp\u003e你可以在任意VPS提供商上购买所需要的服务器，比如说我这边是用的是\u003ca href=\"https://www.google.com/url?sa=t\u0026amp;source=web\u0026amp;rct=j\u0026amp;opi=89978449\u0026amp;url=https://www.racknerd.com/\u0026amp;ved=2ahUKEwj9rN3guvaQAxU3m68BHZHhF5kQFnoECD0QAQ\u0026amp;usg=AOvVaw1f3G5tQVYCJRLV5V-s0O-I\"\n   \n    \n       target=\"_blank\" rel=\"noopener\" \n   \n   class=\"custom-link\"\u003e  \n   RackNerd\u003cspan class=\"external-link\"\u003e↗\u003c/span\u003e\u003c/a\u003e\n，正好赶上双11优惠，花费了70块弄了一个低配的KVM小机子，用作轻量级服务。1vCPU, 1G内存, 20G硬盘空间，3T/月的带宽，虽说配置比较低，但是很适合配置轻量级服务器与学习作用。\u003c/p\u003e","title":"2025_11_16 Build_a_personal_website"},{"content":"我在更新macOS Tahoe 26的时候，整体的液态玻璃效果太抽象了，完全一变以前的简约风格，存在感太强了，和我原来的黑白简约风格很违和。同时由于我之前做的一些ntfs适配，梯子适配的东西全部不能用了，细想之下，我直接把mac出了。\n那么现在我的宿舍桌面就没有主机使用了，考虑到可玩性，我尝试寻找一些能够支持linux的、功耗低、迷你的设备。我考虑了一些类树莓派，但是这种小型的设备，算力支持太低了，而且可能会遇到一些莫名其妙的设备问题，我想要更多的享受linux的生活而不是将时间花费在无止境的维修设备上。同时单纯地嵌入式设备太丑陋了，不像一个合格的产品使用，以及这只是主机，我还需要花费精力给他添加一个显示屏还有多出的线，总之就是各种不方便。\n这时候我将视线投向了微软的surface系列产品，但是我还是遇到了很多的不合适的点。首先是surface新产品太贵了，而旧款式的产品充满了旧时代的审美和旧时代的配置。很难想象一个平板电脑二合一的产品有着能够停的下理想的黑边和十分明显了直角边框。其次就是，他的键盘我不是很需要，我很讨厌传统键盘的方向键设计，以及冗余的全键位设计，以及最不能容忍度半高方向键（这也是我没有买mac book的一部分原因）。\n现在我将实现投向了平板电脑。我去搜索了一下，看到了一款合适的设备，小米平板5。于是我从闲鱼上买了一个成色还可以的板子。\n","permalink":"http://localhost:12409/posts/2025_10_16-try_to_port_my_archlinux_on_xiaomi_pad_5/","summary":"\u003cp\u003e我在更新macOS Tahoe 26的时候，整体的液态玻璃效果太抽象了，完全一变以前的简约风格，存在感太强了，和我原来的黑白简约风格很违和。同时由于我之前做的一些ntfs适配，梯子适配的东西全部不能用了，细想之下，我直接把mac出了。\u003cbr\u003e\n那么现在我的宿舍桌面就没有主机使用了，考虑到可玩性，我尝试寻找一些能够支持linux的、功耗低、迷你的设备。我考虑了一些类树莓派，但是这种小型的设备，算力支持太低了，而且可能会遇到一些莫名其妙的设备问题，我想要更多的享受linux的生活而不是将时间花费在无止境的维修设备上。同时单纯地嵌入式设备太丑陋了，不像一个合格的产品使用，以及这只是主机，我还需要花费精力给他添加一个显示屏还有多出的线，总之就是各种不方便。\u003cbr\u003e\n这时候我将视线投向了微软的surface系列产品，但是我还是遇到了很多的不合适的点。首先是surface新产品太贵了，而旧款式的产品充满了旧时代的审美和旧时代的配置。很难想象一个平板电脑二合一的产品有着能够停的下理想的黑边和十分明显了直角边框。其次就是，他的键盘我不是很需要，我很讨厌传统键盘的方向键设计，以及冗余的全键位设计，以及最不能容忍度半高方向键（这也是我没有买mac book的一部分原因）。\u003cbr\u003e\n现在我将实现投向了平板电脑。我去搜索了一下，看到了一款合适的设备，小米平板5。于是我从闲鱼上买了一个成色还可以的板子。\u003c/p\u003e","title":"2025_10_16 Try_to_port_my_archlinux_on_xiaomi_pad_5"},{"content":"前几天更新archlinux系统，重启之后无法正常进入启动引导界面，这边记录一下如何进行修复。\ngrub引导修复与内核修复 根据 \u0026ldquo;Minimal bash-like line editing\u0026rdquo; in GRUB when booting↗ 中指出，开机只掉到 GRUB 的“Minimal BASH-like line editing…”说明了GRUB无法找到它的配置文件，GRUB无法从FAT分区加载Linux内核。\n我们现在必须要使用Live USB启动Arch系统，再chroot进入修复GRUB。\n创建Arch linux live USB 我们可以从 Arch Linux Downloads↗ 中下载最新的ISO镜像，之后使用一个闲置U盘通过如 Rufus↗ 创建自己的Arch live盘。\n接下来修改自己的启动优先级进入U盘里的live环境。\n确认Arch 安装的分区 我们需要从确认我们安装的Arch分配的磁盘和分区是什么，可以通过以下指令查看：\nlsblk -f 通常会有以下输出：\nnvme0n1p1 vfat EFI nvme0n1p2 swap nvme0n1p3 btrfs ArchRoot 这通常代表了你创建系统时分配的EFI分区，Btrfs根分区。\n挂载分区 # 挂载根分区 mount -t btrfs -o subvol=@home,compress=zstd /dev/nvme0n1p3 /mnt # 挂载EFI(boot)分区 mount /dev/nvme0n1p1 /mnt/boot 内核修复 “提示” 如果没有内核修复的需求可跳过这一小节 在我原先修复完GRUB引导后，进入Arch系统后出现无法正确读取内核文件，估计是更新系统的同时，系统内核并未正常跟新，内核文件损坏：\nLoading initial ramdisk ... error: you need to load the kernel first. 根据 Grub says i need to load kernel first↗ 可知，我们需要重新安装它：\npacman -S linux 如果在安装的过程中出现了\nxxx: Read-only file system error: command failed to execute correctly 可能是之前更新失败中断导致的自动分区保护，我们需要清脏标志位\nfsck.vfat -a -v /dev/nvme0n1p1 结果中如果出现以下字段则代表了成功清除标志位\nDirty bit is set 进入chroot系统并重新生成引导文件 arch-chroot /mnt grub-install --target=x86_64-efi --efi-directory=/efi --bootloader-id=GRUB grub-mkconfig -o /boot/grub/grub.cfg 退出重启 exit umount -R /mnt reboot 接下来拔掉U盘，便可以正常使用了。\n","permalink":"http://localhost:12409/posts/2025_10_16-fix_grub_boot_corruption_and_kernel_corruption_caused_by_arch_update/","summary":"\u003cp\u003e前几天更新archlinux系统，重启之后无法正常进入启动引导界面，这边记录一下如何进行修复。\u003c/p\u003e\n\u003ch2 id=\"grub引导修复与内核修复\"\u003egrub引导修复与内核修复\u003c/h2\u003e\n\u003cp\u003e根据\u003ca href=\"https://bbs.archlinux.org/viewtopic.php?id=257358\"\n   \n    \n       target=\"_blank\" rel=\"noopener\" \n   \n   class=\"custom-link\"\u003e  \n    \u0026ldquo;Minimal bash-like line editing\u0026rdquo; in GRUB when booting\u003cspan class=\"external-link\"\u003e↗\u003c/span\u003e\u003c/a\u003e\n中指出，开机只掉到 GRUB 的“Minimal BASH-like line editing…”说明了GRUB无法找到它的配置文件，GRUB无法从FAT分区加载Linux内核。\u003cbr\u003e\n我们现在必须要使用Live USB启动Arch系统，再chroot进入修复GRUB。\u003c/p\u003e","title":"修复arch更新引起的grub引导破坏和内核损坏"},{"content":"之前做了一份骑行减脂的饮食指南，在这边另开一篇记录一下这段时间的饮食以及体重变化。\n第一周 2025-10-06 早餐：牛奶 250 ml，燕麦 40 g，香蕉 1 根\n午餐：滑蛋牛肉，虾仁西兰花，糙米饭 1 碗，梨 1 个\n晚餐（骑行后）：蔬菜 250 g，肉类 100 g，荞麦面 1 份，鹌鹑蛋 6 个，豆腐 20 g，香蕉 1 根\n总热量：≈ 1900 kcal 蛋白质：≈ 105 g 碳水化合物：≈ 225 g 脂肪：≈ 48 g 饮食结构合理，蔬菜与复合碳水比例良好。\n蛋白质略低，可在午餐或晚餐增加 50 g 鸡胸或 20 g 蛋白粉。\n整体热量略低于计划（2400 kcal）。\n2025-10-07 早餐：牛奶 250 ml，燕麦 40 g，香蕉 1 根\n午餐：莴苣炒肉 1 份，空心菜 1 份，鸭腿 1 个，米饭 1 碗\n骑行前：香蕉 1 根\n晚餐（骑行后）：沙县鸭腿饭（约半份米饭），梨 1 个\n总热量：≈ 2100 kcal 蛋白质：≈ 115 g 碳水化合物：≈ 250 g 脂肪：≈ 65 g 整体饮食结构良好，蛋白质来源丰富（两次鸭腿 + 牛奶 + 肉类），碳水摄入略偏少但分配合理。\n骑行前的香蕉补能及时，骑行后晚餐选择得当，有助糖原恢复。\n今日脂肪略高，主要来自鸭腿，可在未来午餐中减少油量或选择瘦肉替代。\n总体热量约 2100 kcal，略低于目标 2400 kcal。\n2025-10-08 早餐：牛奶 250 ml，燕麦 40 g，香蕉 1 根\n午餐：沙县鸡腿饭（去皮），鸡蛋 1 个\n骑行前：香蕉 1 根\n晚餐（骑行后）：沙县鸭腿饭（去皮），鸡蛋 1 个，梨 1 个\n总热量：≈ 2050 kcal 蛋白质：≈ 125 g 碳水化合物：≈ 260 g 脂肪：≈ 50 g 去皮后脂肪显著下降，整体营养结构更加理想。\n蛋白质充足，碳水摄入合理，能量分布符合骑行日需求。\n骑前香蕉与骑后梨子的时机恰当，有助于能量补给与恢复。\n建议保持此饮食模式，并在午餐或晚餐增加少量蔬菜以补足膳食纤维。\n2025-10-09 早餐：牛奶 250 ml，燕麦 40 g，香蕉 1 根\n午餐：去皮鸭腿 1 个，莴苣炒肉，空心菜，米饭 半份\n晚餐：牛肉 1 份，青菜 250 g，鸡腿 1 个，米饭 半份，梨 1 个\n总热量：≈ 2000 kcal 蛋白质：≈ 130 g 碳水化合物：≈ 220 g 脂肪：≈ 55 g 整体饮食均衡，高蛋白摄入充足，蔬菜比例理想。\n减少主食后热量控制良好，适合恢复日轻度代谢平衡。\n建议保持蛋白与蔬菜比例，恢复期可在早餐稍补碳水，\n晚餐注意控制油脂，维持当前摄入有助稳步减脂与恢复。\n周体重记录 周次 日期范围 体重 (kg) 变化 备注 第 1 周 10-05 ～ 10-11 80.0 — 起始体重 第 2 周 10-12 ～ 10-18 — — — 第 3 周 10-19 ～ 10-25 — — — 第 4 周 10-26 ～ 11-01 — — — ","permalink":"http://localhost:12409/posts/2025_10_06-weight_loss_diary/","summary":"\u003cp\u003e之前做了一份骑行减脂的饮食指南，在这边另开一篇记录一下这段时间的饮食以及体重变化。\u003c/p\u003e\n\u003ch2 id=\"第一周\"\u003e第一周\u003c/h2\u003e\n\u003ch3 id=\"2025-10-06\"\u003e2025-10-06\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e早餐\u003c/strong\u003e：牛奶 250 ml，燕麦 40 g，香蕉 1 根\u003cbr\u003e\n\u003cstrong\u003e午餐\u003c/strong\u003e：滑蛋牛肉，虾仁西兰花，糙米饭 1 碗，梨 1 个\u003cbr\u003e\n\u003cstrong\u003e晚餐（骑行后）\u003c/strong\u003e：蔬菜 250 g，肉类 100 g，荞麦面 1 份，鹌鹑蛋 6 个，豆腐 20 g，香蕉 1 根\u003c/p\u003e","title":"2025_10_06 Weight_loss_diary"},{"content":"这次国庆回家又被父母说太胖了~，最近也买了自行车，前都花了，还是真得动起来啊。大概总结一下在减肥过车过程中需要注意的点。\n饮食问题 热量赤字 减肥的核心是制造能量赤字，当你消耗的热量大于你摄入的热量的时候，你的体脂就会下降了。\n男性维持体重的基础代谢量为 $$ BMR≈66+(13.7×体重kg)+(5×身高cm)−(6.8×年龄) $$\n按照我现在的个人参数来计算，23岁，80kg，178cm，计算出的BMR约为1800kcal，如果我每天都运动的话，日常活动系数可以达到1.55，那么我的维持热量为2800kcal/day，我预计每天骑行20km，那么我运动消耗大致600kcal/day，所以我每天的总消耗为3400kcal。\n如果我想要减肥，我每天需要制造1000kcal的热量缺口，所以我每日的摄入目标为2400kcal。\n营养比例 营养素 占比 每日摄入量 食物示例 食物对应营养含量（约值） 蛋白质 25% 140 g 鸡胸肉 150 g\n鸡蛋 2 个 (100 g)\n牛肉 100 g\n鱼肉 100 g\n虾仁 100 g\n豆腐 100 g\n牛奶 250 ml\n豆浆 250 ml 鸡胸肉 150 g ≈ 35 g ≈ 165 kcal\n鸡蛋 2 个 ≈ 12 g ≈ 140 kcal\n牛肉 100 g ≈ 26 g ≈ 200 kcal\n鱼肉 100 g ≈ 22 g ≈ 110 kcal\n虾仁 100 g ≈ 20 g ≈ 100 kcal\n豆腐 100 g ≈ 8 g ≈ 80 kcal\n牛奶 250 ml ≈ 8 g ≈ 120 kcal\n豆浆 250 ml ≈ 7 g ≈ 90 kcal 碳水化合物 50% 280 g 白米饭 100 g\n红薯 100 g\n燕麦 40 g\n全麦面 100 g\n玉米 100 g\n土豆 100 g\n水果 150 g 白米饭 100 g ≈ 30 g ≈ 130 kcal\n红薯 100 g ≈ 20 g ≈ 85 kcal\n燕麦 40 g ≈ 25 g ≈ 150 kcal\n全麦面 100 g ≈ 60 g ≈ 250 kcal\n玉米 100 g ≈ 22 g ≈ 100 kcal\n土豆 100 g ≈ 18 g ≈ 80 kcal\n水果 150 g ≈ 20 g ≈ 80 kcal 脂肪 25% 60 g 橄榄油 10 g\n坚果 15 g\n牛油果 50 g\n芝麻 10 g\n鱼油 5 g\n三文鱼 100 g\n蛋黄 1 个 (20 g) 橄榄油 10 g ≈ 10 g ≈ 90 kcal\n坚果 15 g ≈ 9 g ≈ 85 kcal\n牛油果 50 g ≈ 7 g ≈ 70 kcal\n芝麻 10 g ≈ 5 g ≈ 45 kcal\n鱼油 5 g ≈ 5 g ≈ 45 kcal\n三文鱼 100 g ≈ 13 g ≈ 200 kcal\n蛋黄 1 个 ≈ 5 g ≈ 60 kcal 每餐能量分配 餐别 占全天热量比例 总热量 (kcal) 蛋白质 (g / kcal) 碳水 (g / kcal) 脂肪 (g / kcal) 早餐 20 % 480 kcal 30 g ≈ 120 kcal 55 g ≈ 220 kcal 15 g ≈ 140 kcal 午餐 40 % 960 kcal 60 g ≈ 240 kcal 120 g ≈ 480 kcal 26 g ≈ 240 kcal 骑行前 10 % 240 kcal 8 g ≈ 30 kcal 45 g ≈ 180 kcal 3 g ≈ 30 kcal 晚餐（骑行后） 30 % 720 kcal 52 g ≈ 210 kcal 80 g ≈ 320 kcal 18 g ≈ 190 kcal 合计 100 % 2400 kcal 150 g ≈ 600 kcal 300 g ≈ 1200 kcal 62 g ≈ 560 kcal ","permalink":"http://localhost:12409/posts/2025_10_05-how_to_lose_weight_reasonably/","summary":"\u003cp\u003e这次国庆回家又被父母说太胖了~，最近也买了自行车，前都花了，还是真得动起来啊。大概总结一下在减肥过车过程中需要注意的点。\u003c/p\u003e\n\u003ch2 id=\"饮食问题\"\u003e饮食问题\u003c/h2\u003e\n\u003ch3 id=\"热量赤字\"\u003e热量赤字\u003c/h3\u003e\n\u003cp\u003e减肥的核心是制造能量赤字，当你消耗的热量大于你摄入的热量的时候，你的体脂就会下降了。\u003cbr\u003e\n男性维持体重的基础代谢量为\n$$ BMR≈66+(13.7×体重kg)+(5×身高cm)−(6.8×年龄) $$\u003cbr\u003e\n按照我现在的个人参数来计算，23岁，80kg，178cm，计算出的BMR约为1800kcal，如果我每天都运动的话，日常活动系数可以达到1.55，那么我的维持热量为2800kcal/day，我预计每天骑行20km，那么我运动消耗大致600kcal/day，所以我每天的总消耗为3400kcal。\u003cbr\u003e\n如果我想要减肥，我每天需要制造1000kcal的热量缺口，所以我每日的摄入目标为2400kcal。\u003c/p\u003e","title":"2025_10_05 How_to_lose_weight_reasonably"},{"content":"我们现在通过DMA的方式来进行UART的数据搬运，所以对应的中断响应函数也需要重新编写。接下来我会简要的解释一下更改DMA前后中断响应函数的原理和实现方式。\n纯寄存器搬运 RX 每来一个字节，串口外设置位 RXNE 标志 → 触发一次中断 → CPU 进入 Uartx_IRQ → 读取 RDR → 存到软件 FIFO。\nTX 每发完一个字节，串口外设置位 TXE 标志 → 触发一次中断 → CPU 进入 Uartx_IRQ → 从软件 FIFO 取出一个字节写入 TDR。\n作为普通的UART发送接受方式，每字节都会产生一次中断以及寄存器访问，所以在高波特率的情况下，会占用大量CPU资源，可能导致中断请求IRQ的生成速率远超处理能力，产生中断风暴等其他后果。\nDMA搬运 RX: DMA Circile + 环形RX缓冲+ IDLE DMA持续把数据从接受寄存器RDR搬运到内存的环形缓冲区，当总线空闲的时候，UART触发IDLE line中断，CPU只需要查看NDTR的新数据指针就可以知道刚才发送来了哪些数据，并切通过中断触发的用户回调来完成数据的处理。\nTX: DMA Normal + 环形TX缓冲 应用层将要发送的数据写入软件维护的 内存环形 TX 缓冲区，并更新 head 指针。如果 DMA 空闲，驱动会挑选环形缓冲中一段 连续数据块（tail → head 或 tail → buffer_end），启动一次 DMA Normal 模式传输。DMA 自动将这一段内存逐字节搬运到 USARTx-\u0026gt;TDR，由硬件时序发出。当传输完成时，触发 DMA TC（传输完成）中断。在中断回调中：推进 tail 指针，标记这段数据已经发完；如果环形缓冲中还有剩余数据，再次启动下一次 DMA，知道没有新数据接入。\nRX: UDS_Write size_t UDS_Write(uds_t* h, const uint8_t* data, size_t len){ if(!h || !len) return 0; size_t written = 0; while(written \u0026lt; len){ size_t head = h-\u0026gt;tx_head; size_t tail = h-\u0026gt;tx_tail; size_t free_space = (tail + UDS_TX_BUF_SIZE - head - 1) % UDS_TX_BUF_SIZE; if(free_space == 0){ // 没空间：尝试触发一次 DMA 发送，不行就退出 if(_tx_try_kick(h) == 0) break; continue; } size_t chunk = len - written; if(chunk \u0026gt; free_space) chunk = free_space; // 写入环形 size_t endspace = UDS_TX_BUF_SIZE - head; size_t c1 = (chunk \u0026lt; endspace) ? chunk : endspace; memcpy(\u0026amp;h-\u0026gt;tx_buf[head], \u0026amp;data[written], c1); if(chunk \u0026gt; c1){ memcpy(\u0026amp;h-\u0026gt;tx_buf[0], \u0026amp;data[written + c1], chunk - c1); } __disable_irq(); h-\u0026gt;tx_head = (head + chunk) % UDS_TX_BUF_SIZE; __enable_irq(); written += chunk; _tx_try_kick(h); } return written; } 首先，调用 UDS_Write() 会把应用层要发送的数据写进环形 TX 缓冲区。\n写之前先检查缓冲区是否有空闲：通过 head 和 tail 计算空闲空间。 如果缓冲区满了，会尝试调用 _tx_try_kick() 启动 DMA 把旧数据送出去，为新数据腾出空间；若 DMA 仍在忙，就暂时退出（非阻塞）。 写入缓冲区的过程：\n如果 head \u0026gt; tail，说明缓冲区剩余空间是连续的，直接写入即可。 如果 head \u0026lt; tail，缓冲区尾部到末尾是一段连续空间，先写这一段，如果数据还没写完，再从缓冲区起始地址写剩余部分。 最后更新 head 指针（指向下一个空闲位置），此时数据已经安全放入环形缓冲。 接下来 _tx_try_kick() 会检查 DMA 是否空闲：\n若 DMA 不忙，取出 一段连续的数据（从 tail 开始，长度可能是 head - tail，或者到缓冲末尾的一段 BUF_SIZE - tail）。 把这段地址和长度交给 HAL_UART_Transmit_DMA()。 在启动之前需要做 dcache_clean()（仅 H7 开启 D-Cache 时需要），保证 DMA 读到的是内存中最新的数据。 然后置位 tx_dma_busy = true，并保存 tx_dma_len = len 以便回调里推进 tail。 当 DMA 把这一段数据搬运完毕，会触发 DMA 传输完成中断：\n在 HAL_UART_TxCpltCallback() 里，用之前保存的 tx_dma_len 推进 tail 指针。\n清除 tx_dma_busy，并尝试再次调用 _tx_try_kick()：\n如果缓冲里还有数据，立即发下一段； 如果缓冲已空，就可以触发 on_tx_done 通知应用层。 这样，整个环形 TX 缓冲和 DMA Normal 模式就结合起来了：\n应用层只管不断往环里写数据（非阻塞）； DMA 负责一次次批量搬运； CPU 只需在回调中推进指针并调度下一段，大大降低了中断频率和 CPU 占用率。 ","permalink":"http://localhost:12409/posts/2025_09_16-register_method_and_hal_method_to_complete_interrupt_serial_port_processing/","summary":"\u003cp\u003e我们现在通过DMA的方式来进行UART的数据搬运，所以对应的中断响应函数也需要重新编写。接下来我会简要的解释一下更改DMA前后中断响应函数的原理和实现方式。\u003c/p\u003e","title":"2025_09_16 Register_method_and_hal_method_to_complete_interrupt_serial_port_processing"},{"content":"今天在移植我写好的底层DMA驱动包到目标工程的时候，主要遇到了以下的几个问题。\nQ: 避免符号冲突 A: 根据原有目标工程的宏定义，替换修改驱动包的宏定义。\nR: 我的发送端DMA驱动的UART能够实现条件触发进入发送逻辑，确保好一定的发送缓冲区大小，在尽量不堵塞的情况下能够实现最大的发送速率 R: 我的接收端DMA驱动的UART能够实现实时待命，一旦接收缓冲区有数据，就搬运到接受端内存中 R: 在初始化的阶段能够通过统一的逻辑实现DMA驱动UART和普通UART，能够自主选择是否使用DMA R: 将其中一个UART初始化为普通UART，作为串口调试信息输出 ","permalink":"http://localhost:12409/posts/2025_09_15-how_to_resolve_conflicts_between_self_build_packages_and_old_projects/","summary":"\u003cp\u003e今天在移植我写好的底层DMA驱动包到目标工程的时候，主要遇到了以下的几个问题。\u003c/p\u003e\n\u003ch2 id=\"q-避免符号冲突\"\u003eQ: 避免符号冲突\u003c/h2\u003e\n\u003cp\u003eA: 根据原有目标工程的宏定义，替换修改驱动包的宏定义。\u003c/p\u003e","title":"2025_09_15 How_to_resolve_conflicts_between_self_build_packages_and_old_projects"},{"content":"今天在写驱动的时候，涉及到DMA和Cache的一致性问题，对于其中的一些疑惑做了记录。\nDMA和CPU访问路径 CPU访问内存的时候，通常先访问cache（L1/L2），只有cache不命中的时候才回去访问主存（SRAM/DDR）。 DMA控制器访问内存的时候，一般是直接通过总线访问主存，不经过CPU的cache。 CPU → DMA → 设备（CPU写数据给外设）: ------------------------------------ [CPU寄存器/程序] │ ▼ [CPU Cache] (CPU写数据 → 可能停留在cache里) │ (Clean Cache: 写回内存，保证DMA可见) ← 传输前执行 │ ▼ [内存RAM] ← DMA要读这里 │ ▼ [DMA总线] │ ▼ [外设设备] (UART/SPI/网卡等) 设备 → DMA → CPU（外设写数据给CPU）: ------------------------------------ [外设设备] (ADC/网卡等) │ ▼ [DMA总线] │ ▼ [内存RAM] ← DMA写入数据 │ (Cache可能仍保存旧数据) │ (Invalidate Cache: 标记无效，下次CPU从内存取) ← 传输后执行 │ ▼ [CPU Cache] │ ▼ [CPU寄存器/程序] ","permalink":"http://localhost:12409/posts/2025_08_25-dma_and_cache_consistency/","summary":"\u003cp\u003e今天在写驱动的时候，涉及到DMA和Cache的一致性问题，对于其中的一些疑惑做了记录。\u003c/p\u003e\n\u003ch2 id=\"dma和cpu访问路径\"\u003eDMA和CPU访问路径\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCPU访问内存的时候，通常先访问cache（L1/L2），只有cache不命中的时候才回去访问主存（SRAM/DDR）。\u003c/li\u003e\n\u003cli\u003eDMA控制器访问内存的时候，一般是直接通过总线访问主存，不经过CPU的cache。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-md\" data-lang=\"md\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eCPU → DMA → 设备（CPU写数据给外设）:  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e------------------------------------\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    [CPU寄存器/程序]  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           │\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           ▼\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      [CPU Cache]   (CPU写数据 → 可能停留在cache里)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           │\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     (Clean Cache: 写回内存，保证DMA可见)  ←  传输前执行\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           │\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           ▼\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        [内存RAM]  ← DMA要读这里\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           │\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           ▼\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        [DMA总线] \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           │\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           ▼\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        [外设设备]  (UART/SPI/网卡等)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-md\" data-lang=\"md\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e设备 → DMA → CPU（外设写数据给CPU）:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e------------------------------------\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       [外设设备]  (ADC/网卡等)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           │\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           ▼\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        [DMA总线] \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           │\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           ▼\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        [内存RAM]  ← DMA写入数据\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           │\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     (Cache可能仍保存旧数据) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           │\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     (Invalidate Cache: 标记无效，下次CPU从内存取)  ← 传输后执行\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           │\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           ▼\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      [CPU Cache]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           │\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           ▼\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    [CPU寄存器/程序]  \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"2025_08_25 Dma_and_cache_consistency"},{"content":"这段时间在尝试用DMA来运输串口数据，回去翻数据手册，发现好多术语都忘记的差不多了，现在对于学习中遇到的问题做一个记录。\nMDMA、DMA、BDMA MDMA (Master DMA) 主DMA控制器，专门为大规模内存数据搬运和外设高速数据传输设计，通常用于SDRAM、LCD、GPU、图像处理、以太网大数据搬运。\nDMA (Direct Memory Access) 直接储存器访问控制器，在不经过CPU的情况下进行数据的搬运，通常适用于SPI、ADC、DAC、I2C、USART等外设的数据搬运。\nBDMA (Basic DMA) 基本DMA控制器，更加轻量的DMA，一般用于较小数据的搬运任务，通常适用于某些特定外设，如USB、SPI Flash、QSPI等。\n电源域下的分类 在STM32H7中，芯片内部被分为多个电源域，D1电源域下，使用的总线矩阵是64bit的AXI总线，MDMA也是通过64bit的AXI总线接入D1域的总线矩阵的，并且有专门的32bit的AHB总线直通CPU。D2电源域下，使用的总线矩阵为32bit的AHB总线，两个DMA控制器DMA1和DMA2都通过32bitAHB总线接入AHB总线矩阵。在D3电源域，资源比较少，BDMA通过32bit总线接入32bit的AHB总线矩阵。\n缓冲(Buffer)区 由于DMA只是负责数据传输的通道，不涉及保存数据，所以说在使用的时候通常要结合缓冲区来储存数据。\n普通缓冲 一次性传输，通过DMA传输N个数据到一块缓冲区，搬运结束后触发“传输完成中断”。\n环形缓冲 缓冲区地址固定，DMA传输到尾部后从头覆盖，构成一条环形，常用于连续数据流如UART 接收、音频流、传感器数据等。\n双缓冲 通过给DMA分配两块缓冲区A和B，外设不停在两块区域内进行写入或者读取。\n双缓冲如分配Buffer A和Buffer B，DMA开始将数据写入Buffer A，当A填满的时候，DMA自动切换到Buffer B，这时候CPU就可以安全地处理Buffer A的数据。当B填满的时候，DMA又切换为A，CPU再处理B，如此往复循环，DMA和CPU交替使用两块缓冲区。\n两块缓冲区A和B作用完全一致，仅区别为某一时刻谁被DMA写，谁被DMA读。\nDMA和CPU的并行性 在“双缓冲”章节，我疑问于为什么需要双缓冲来避免冲突，其中的“不能同时工作”指的是不能同时对统一块缓存进行操作。主要是两个方面的原因，分别是数据一致性以及总线仲裁的问题。如果DMA 正在往 Buffer A 写数据时，如果 CPU 也在读这个缓冲，可能读到部分旧数据加上部分新数据，导致数据不完整甚至数据错误，同时DMA和CPU共享总线（AHB/AXI），访问同一地址会导致总线仲裁，降低数据传输效率。\nAMBA 总线协议 上一步提到的AHB和AXI都是总线协议，属于AMBA（Advanced Microcontroller Bus Architecture，高级微控制器总线架构） 标准里的两种常见总线。\nAHB总线 全称为Advanced High-performance Bus（高级高性能总线），仲裁机制简单，通常只有一个master在用。在STM32H7中，DMA、CPU、外设都通过AHB访问内存和外设。\nAXI总线 全程为Advanced eXtensible Interface（高级可扩展接口），支持多机并行访问（CPU、DMA、GPU、外设等可以同时发起访问），支持更高的数据带宽。在 STM32H7 中，Cortex-M7 内核挂在 AXI 总线上，能高速访问 AXI SRAM/外部 SDRAM。\n","permalink":"http://localhost:12409/posts/2025_08_21-microcontroller_literacy_taking_stm32h7_as_an_example/","summary":"\u003cp\u003e这段时间在尝试用DMA来运输串口数据，回去翻数据手册，发现好多术语都忘记的差不多了，现在对于学习中遇到的问题做一个记录。\u003c/p\u003e\n\u003ch2 id=\"mdmadmabdma\"\u003eMDMA、DMA、BDMA\u003c/h2\u003e\n\u003ch3 id=\"mdma-master-dma\"\u003eMDMA (Master DMA)\u003c/h3\u003e\n\u003cp\u003e主DMA控制器，专门为大规模内存数据搬运和外设高速数据传输设计，通常用于SDRAM、LCD、GPU、图像处理、以太网大数据搬运。\u003c/p\u003e","title":"2025_08_21 Microcontroller_literacy_taking_stm32h7_as_an_example"},{"content":"Modbus 基本命令 0x03 \u0026ndash; 查询从设备寄存器内容 主设备发送报文 从设备地址范围 功能码 起始寄存器地址 寄存器个数 CRC校验码 / 0x01 - 0xFF (1 字节) 0x03 (1 字节) (2 字节) (2 字节) (2 字节) 主设备接受报文 从设备地址范围 功能码 数据区字节数 数据区 CRC校验码 / 0x01 - 0xFF (1 字节) 0x03 (1 字节) 2 * 寄存器个数 (1 字节) 寄存器内容 (2 * 寄存器个数字节) (2 字节) 例子： 读所有数据发送命令举例 主设备发送报文 从设备地址范围 功能码 起始寄存器地址 寄存器个数 CRC校验码 / 01 03 00 00 00 47 xx xx 说明： 从寄存器 0 开始，连续读 72 (0x47) 个寄存器数据，每一路数据占用一路寄存器。\n主设备接受报文 从设备地址范围 功能码 数据区字节数 数据区 CRC校验码 / 01 03 8E 12 56 27 01 11 EC \u0026hellip;.. (16 进制 2 个字节为一个参数，返回 142 个字节数据 72 个参数) XX XX 说明： 数据区总共有 16 组数据，32 个字节，每组数据为 2 个字节，高字节在前低字节在后；CRC 校验码要根据实际数据得出；如下为举例，其它所有参数依此类推。\n其中： 数据区 1256H 代表数据 4694；如电压量程为 30V，即实际电压 = 4694 / 10000 * 30 = 4694 * 0.003 = 14.082V； 2701H 代表数据 10001；如电压量程为 30V，即实际电压 = 10001 / 10000 * 30 = 10001 * 0.003 = 30.003V。\n0x06 \u0026ndash; 对从设备单个寄存器置数 主设备发送报文 从设备地址范围 功能码 起始寄存器地址 寄存器个数 CRC校验码 / 0x01 - 0xFF (1 字节) 0x06 (1 字节) (2 字节) (2 字节) (2 字节) 主设备接受报文 从设备地址范围 功能码 数据区字节数 数据区 CRC校验码 / 0x01 - 0xFF (1 字节) 0x06 (1 字节) (2 字节) (2 字节) (2 字节) 例子： 修改采样率命令举例 主设备发送报文 从设备地址范围 功能码 寄存器地址 写入的数据 CRC校验码 / 01 06 00 EF 00 09 xx xx 说明： 00EFH 地址对应的寄存器内容为采样率，0009 是 50ksps 采样率对应的代码值。\n主设备接受报文 从设备地址范围 功能码 寄存器地址 写入的数据 CRC校验码 / 01 06 00 EF 00 09 xx xx 说明： 返回值与主设备发送报文相同。\n采样率指标 采样率 采样点 采样方式 采样率代码 100sps 512 同步采样 0000 500sps 512 同步采样 0001 1ksps 1024 同步采样 0002 2ksps 1024 同步采样 0003 4ksps 1024 同步采样 0004 5ksps 1024 同步采样 0005 10ksps 2048 同步采样 0006 20ksps 4096 同步采样 0007 40ksps 4096 同步采样 0008 50ksps 4096 同步采样 0009 100ksps 16384 轮询采样 0010 150ksps 16384 轮询采样 0011 寄存器参数说明 寄存器地址 (括号内为十进制) 寄存器内容 数据类型 数据长度 数据说明 (DATA 为从模块读出的数据) 0000-0007H (0-7) 1-8 路有效值 只读 16 位 无符号，值 = DATA * 量程 / 10000 0018-001FH (24-31) 1-8 路频率 只读 16 位 无符号整数，分辨率单位由 00EBH(235) 寄存器设置；最大值 65535 表示数据超范围溢出。注意 00EFH(239) 采样率设置寄存器要大于输入频率才能准确测量：\n值=DATA / 100（分辨率 0.01Hz）\n值=DATA / 10（分辨率 0.1Hz，出厂默认）\n值=DATA（分辨率 1Hz）\n值=DATA * 10（分辨率 10Hz） 0040-0047H (64-71) 1-8 路占空比 只读 16 位 无符号，值 = DATA / 100（单位 %，频率大于 15kHz 误差超过 1%，频率越高误差越大不保证精度） 0048-0057H (72-87) 1-8 路脉宽最大值 只读 32 位 无符号，值 = DATA / 10（分辨率 0.1μs）（具有最大值记录功能，读取后清零） 00FEH(254) 采样点数 只读 16 位 总采样点数，不同采样率采样点数不同，参见 采样率指标表 00E5H(229) 网口地址 1 读/写 1-250（默认 1，255 为广播地址） 00E6H(230) 网口波特率 1 读/写 默认 115200bps（可改为 230400 / 256000 / 460800 / 921600 bps） 00E9H(233) 更新时间设置 1 读/写 0: 正常时间（缺省采样点）\n1: 时间减半（采样点减半）\n2: 四分之一时间（采样点减至四分之一） 00EBH(235) 频率分辨率设置 1 读/写 0: 0.01Hz\n1: 0.1Hz（缺省）\n2: 1Hz\n3: 10Hz（针对 0018H-001FH 频率数据寄存器） 00EFH(239) 采样率 1 读/写 0: 100sps\n1: 500sps\n2: 1ksps\n3: 2ksps\n4: 4ksps\n5: 5ksps\n6: 10ksps\n7: 20ksps（缺省）\n8: 40ksps\n9: 50ksps\n10: 100ksps（波形触发记录功能无效）\n11: 150ksps（波形触发记录功能无效）\n（过采样原理：采样率根据实际输入的频率范围来选择，采样率越高，采到的干扰信号越多） ","permalink":"http://localhost:12409/posts/2025_08_07-zh3408_modbus_document_instructions_for_use/","summary":"\u003ch2 id=\"modbus-基本命令\"\u003eModbus 基本命令\u003c/h2\u003e\n\u003ch3 id=\"0x03--查询从设备寄存器内容\"\u003e\u003ccode\u003e0x03\u003c/code\u003e \u0026ndash; 查询从设备寄存器内容\u003c/h3\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e主设备发送报文\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e从设备地址范围\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e功能码\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e起始寄存器地址\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e寄存器个数\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003eCRC校验码\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e/\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003e0x01\u003c/code\u003e - \u003ccode\u003e0xFF\u003c/code\u003e (\u003ccode\u003e1\u003c/code\u003e 字节)\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003e0x03\u003c/code\u003e (\u003ccode\u003e1\u003c/code\u003e 字节)\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e(\u003ccode\u003e2\u003c/code\u003e 字节)\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e(\u003ccode\u003e2\u003c/code\u003e 字节)\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e(\u003ccode\u003e2\u003c/code\u003e 字节)\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e主设备接受报文\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e从设备地址范围\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e功能码\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e数据区字节数\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e数据区\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003eCRC校验码\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e/\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003e0x01\u003c/code\u003e - \u003ccode\u003e0xFF\u003c/code\u003e (\u003ccode\u003e1\u003c/code\u003e 字节)\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003e0x03\u003c/code\u003e (\u003ccode\u003e1\u003c/code\u003e 字节)\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003e2\u003c/code\u003e * 寄存器个数 (\u003ccode\u003e1\u003c/code\u003e 字节)\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e寄存器内容 (\u003ccode\u003e2\u003c/code\u003e * 寄存器个数字节)\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e(\u003ccode\u003e2\u003c/code\u003e 字节)\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch4 id=\"例子-读所有数据发送命令举例\"\u003e例子： 读所有数据发送命令举例\u003c/h4\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e主设备发送报文\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e从设备地址范围\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e功能码\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e起始寄存器地址\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e寄存器个数\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003eCRC校验码\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e/\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003e01\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003e03\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003e00 00\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003e00 47\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ccode\u003exx xx\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e说明： 从寄存器 \u003ccode\u003e0\u003c/code\u003e 开始，连续读 \u003ccode\u003e72\u003c/code\u003e (\u003ccode\u003e0x47\u003c/code\u003e) 个寄存器数据，每一路数据占用一路寄存器。\u003c/p\u003e","title":"ZH-3408 Modbus 命令码与关键参数配置速查手册"},{"content":"TODO gpt answer↗ DMA 定义 DMA，全程Direct Memory Access，即直接储存器访问。DMA的作用就是实现数据的直接传输，从而去掉了传统数据传输需要CPU寄存器参与的环节，大大节省了CPU资源的消耗。此过程主要涉及外设与存储器之间的以及存储器与存储器之间提供高速数据传输，本质上都是数据从内存的某一区域传输到内存的另一区域外设的数据寄存器本质上就是内存的一个存储单元 。\nDMA请求方式 DMAMUX（DMA Multiplexer）是 STM32 某些新系列（如 G0、G4、L4+、H7 等）里新增的一个DMA 请求路由器。\n在早期的STM32F1系列中，比如有0-7路共八路DMA通道。其中每一路通道可以响应多个外设的请求，但是每一路通道每一次只能响应一个外设的请求。如果遇到了两个外设事件同时需要申请相同的DMA传输通道就麻烦了。\n所以说，后来STM32F4系列采用了和F1写列不同的DMA结构，DMA的请求表分为了Channel和Stream通道，我这时候就能够在选择同一个channel的同时，选择不同的stream来同时分配DMA通道。但是由于一一对应的关系，我某个外设的请求只能申请到Channel0的Steam1和2，而不能申请到别的DMA通道。这样就可能遇到一件事情，当我某一个通道十分繁忙的时候，另一个通道十分空闲。\n所以这时候，就出现了DMAMUX。\nUSART原理 USART（Universal Synchronous/Asynchronous Receiver/Transmitter，通用同步/异步收发器）是 MCU 内部的一个硬件外设，用来进行串行通信。\n我们常用的是异步模式，发送端在每帧数据前后自动添加 起始位 (Start bit) 和 停止位 (Stop bit)，用来标记帧的开始和结束，常用格式为：\n1 Start bit + 8 Data bits + [Parity bit] + 1 Stop bit\n这种异步通信方式不需要时钟线，我们靠约定好的波特率保证发送端和接收端采样对齐。\nUSART收发方式 轮询（阻塞） 轮询方式，顾名思义，CPU需要不断检查发送缓冲标志位，直到可以写下一个字节。比如我们使用9600bps的波特率，1字节（10bit，包含起始/停止位）需要大约1ms才能够发完，在发送完成前，CPU一直会被卡在循环中。\n中断（非阻塞） 每当USART发送完一个字节，标志位触发中断，并把下一个字节写入寄存器。如上述的9600波特率，CPU平时可以做别的事情，我们只需要每隔1ms左右进一次中断写寄存器。\nDMA DMA方式会将自动从内存搬运数据到USART寄存器，硬件负责逐字转发，在此期间，CPU完全不用管，只需要DMA完成中断。\nDMA驱动USART方式 我现在需要通过DMA收发方式来替换USART的驱动，将所有的设置通过结构体变量做好通用化设计，之后通过将板上的两个USART连接起来进行收发测试。\n","permalink":"http://localhost:12409/posts/2025_08_06-stm32h7_serial_port_dma_driver_principle/","summary":"\u003ch2 id=\"todo\"\u003eTODO\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://chatgpt.com/share/6892c3d9-0290-800d-b03a-f2cd23619f65\"\n   \n    \n       target=\"_blank\" rel=\"noopener\" \n   \n   class=\"custom-link\"\u003e  \n   gpt answer\u003cspan class=\"external-link\"\u003e↗\u003c/span\u003e\u003c/a\u003e\n\u003c/p\u003e\n\u003ch2 id=\"dma-定义\"\u003eDMA 定义\u003c/h2\u003e\n\u003cp\u003eDMA，全程Direct Memory Access，即直接储存器访问。DMA的作用就是实现数据的直接传输，从而去掉了传统数据传输需要CPU寄存器参与的环节，大大节省了CPU资源的消耗。此过程主要涉及外设与存储器之间的以及存储器与存储器之间提供高速数据传输，本质上都是数据从内存的某一区域传输到内存的另一区域\u003cspan class=\"sidenote-number\"\u003e\u003csmall class=\"sidenote\"\u003e外设的数据寄存器本质上就是内存的一个存储单元\u003c/small\u003e\u003c/span\u003e\n\n。\u003c/p\u003e","title":"STM32H7之串口DMA驱动原理"},{"content":"今天在尝试寻找一个程序问题的时候，想到了我是不是可以在nvim上添加一个调试的插件，我在搜索的过程中发现一篇有意思的讨论 how many of you use a debugger with nvim↗ 。题主在讨论中说到了“我在使用 VS Code 时从未设置或使用过调试器，并且一直觉得调试器可能有用却也可能麻烦，所以我现在在考虑是否值得在迁移到 Neovim 后去研究它的调试功能”。\n讨论焦点 对于这篇帖子的讨论观点主要分为以下几种：\n“Print永远滴神”： 有大约五分之一的人认为调试器太慢、太复杂，反而print显得直接明了，不少人声称甚至在几十万行的项目中只依靠print来完成程序的调试。 “调试器无所不能”： 断点、变量可视化、单步执行、状态回溯、运行时修改对象……这些都是 print 难以替代的功能，特别是在调试复杂状态机或大型类系统时。 “Neovim的调试器体验差”： 不是不想用，而是用得太痛苦。DAP 配置繁琐、UI 不友好、调试流程割裂，甚至还会导致程序行为变化。最后，还是回归 VS Code、IntelliJ 或 Xcode。 “UNIX哲学派”： 这部分人认为 Neovim 作为一个纯粹的文本编辑器，不需要调试功能，这些额外功能就交给别的工具来实现。 我为什么选择使用Neovim 我愿意使用Neovim的原因可以分为以下几点：\n这是一种键盘友好的文本编辑器。 能够高度定制化你的需求，尽管有一定的门槛，但是经过调整之后能够找到适合自己的输入体验。 高度一致化的输入体验，经过一定的插件整合，我能够在同一种输入体验下完成尽可能多的输入环境需求，而不是无限制得引入重量级的IDE。 高度定制化的Neovim是否背叛了Unix哲学 在给 讨论焦点 一节中的“UNIX哲学派”命名的时候，我顺便去搜寻了下人们对于Neovim的UNIX哲学的看法，确实发现了一些很有意思的内容。\nThe Book of Neo↗ 的作者模仿 《摩西十戒》↗ 写下了《NeoLORD 的十条诫命》，以下是关于其内容的翻译供大家一乐。\nNeoLORD 的十条诫命 80 lines 1. Thou shalt abide by the philosophy of my right hand: “Thou shalt do one thing, and do it well.” The $EDITOR is a craft, created to create. It is the crafter of crafters. Do not fall into the traps of the cursèd devil which shall not be named, and do more than is intended. I am the NeoLORD.\n汝当遵循吾右手的哲学：“汝当专一其事，精其所精。” $EDITOR 乃神圣之工艺，生来为创造而生，是工匠中的工匠。切勿堕入那不可名状之魔的陷阱——贪多务广，违背初衷。 我乃 NeoLORD。\n2. Thou shalt not use editors other than the venerable Neovim; for I the NeoLORD am a jealous God, and will destroy all that create with no regard to their true creator. I am the NeoLORD.\n汝不可使用 Neovim 之外之编辑器。 因为我，NeoLORD，是妒忌之神，凡无视真正创造者而妄作他器者，必遭我之毁灭，永堕 IDE 之牢笼。 我乃 NeoLORD。\n3. Thou shalt abstain from usage of VimScript in favor of Lua. The venerable VimScript will be kept alive, since he is still useful, but beware; old wineskins will break eventually. I am the NeoLORD.\n汝当弃用 VimScript，转而皈依 Lua。 虽古老之 VimScript 尚存其用，然陈酒袋终将破裂。吾已赐汝新皮囊，汝当谨慎斟酌。 我乃 NeoLORD。\n4. Thou shalt make the fullest use of the tools that the NeoLORD has graciously provided to you. Give LSP and Treesitter their due homage. I am the NeoLORD.\n汝当善用吾所赐之神圣工具。 当向 LSP 与 Treesitter 献上敬意。此为圣礼，不容懈怠。 我乃 NeoLORD。\n5. Honor plugin maintainers with the utmost respect. They are not subject to your fleeting whims, and are free to do as they please with the fruits of their labor. Must a conflict arise, thou shalt resolve thy disagreements through civil discussion. Take care, and wield the mighty fork with caution. I am the NeoLORD.\n汝当敬重插件的造物者。 他们非汝一时之所欲可左右，其劳作之果，亦不为尔独享。若有争端，汝当理性交涉；必要时，方可挥动那威力巨大的 fork，然须慎之又慎。 我乃 NeoLORD。\n6. Beware the temptresses of useless plugins. Do not let them sour your desire to create. I am the NeoLORD.\n当警惕虚妄插件之诱惑。 切勿让它们腐蚀汝创造之心志，陷入配置地狱之苦。 我乃 NeoLORD。\n7. Thou shalt respect Vim and its contributions to the world, and upstream any applicable patches, for the spirit of Bram shall live forever and ever. I am the NeoLORD.\n汝当尊重 Vim 及其对世界之贡献。 若能回馈补丁于其上游，更当尽力为之。因为 Bram 的灵魂将与代码同在，直到永远。 我乃 NeoLORD。\n8. Thou shalt not act in sloth, lest you perish in the bottomless pits of the lazy Inferno. The NeoLORD your God is not a lazy God; thou shalt instead weave thy configurations by hand. For the lazy folk are unable to partake in the NeoLORD’s wisdom, and their fingers will rot from confusion. I am the NeoLORD.\n懒惰者必将堕入无底之惰狱。 NeoLORD 并非懒神，汝亦不可依赖懒人配置如 LazyVim。 汝当亲手编织 config，方得其真谛。否则汝之指，将因混乱而枯萎。 我乃 NeoLORD。\n9. Thou shalt not blaspheme against the spirit of modality, for whoever disowns the other modes in favor of insert-only mode shall never be forgiven until they repent of their ways.\n汝不可亵渎“模式”的圣灵。 唯用插入模式者，若不悔改，永不得赦。 汝当尊崇 Normal 与 Visual，因其蕴藏强大之力。\n10. Do not distress over the transgressions of the ignorant, for everyone is a sinner in the NeoLORD’s presence. Instead, lead them towards repentance and the narrow gate of change. I am the NeoLORD.\n勿因无知者之愚行而动怒。 因所有人在 NeoLORD 面前皆为罪人。引导他们悔改，引他们走向“变更”之窄门。 我乃 NeoLORD。\n这些戒令虽然夸张滑稽，但是能够看出Neovim社区的一种价值观：自由、克制、纯粹、可组合、可配置但不强求整合。\nReddit上关于 The Book of Neo↗ 的讨论也很有意思，大家可以自行前往观看。\nDo one thing, and do it well. Don\u0026rsquo;t be like Emacs.\n这话其实很讽刺，在他看来Neovim在越来越像Emacs，这完全是对UNIX哲学的背叛与讽刺。\u0026ldquo;intercaetera\u0026quot;如此提出了这个 观点↗ 。\n“做一件事，做好它。别学Emacs。” 。 考虑到现在有那么多 Neovim 插件，基本上是用 Lua 重写了 Linux/Unix 的各种小工具。 相比 10 年前的 Vim，Neovim 实际上已经大概成了 Emacs 的 75%。\n或许\u0026quot;intercaetera\u0026quot;认为插件越多，越复杂，就越偏离 UNIX 哲学提倡的“做一件事，做好它”的理念。但我认为如果有一天Neovim背叛了UNIX精神，不是因为他能够做很多事情，而是它的功能被绑定在一起，无法解耦。\n真正违背 UNIX 精神的，是“opinionated projects”，它们会对用户说：“你必须按我预想的方式使用我”，比如说某些Neovim发行版（LazyVim）、某些全能插件一次性绑定多个行为等。这才是用户自由的障碍。而“插件”本身，其实正是 Neovim 保留 UNIX 式模块化理念的体现。\nWrite programs that do one thing and do it well.\n但现在人们经常省略“写程序”这部分，结果把整句话的意思搞错了\u0026ldquo;someboddy\u0026quot;在下面进行了 反驳↗ 。\n“写程序就是做一件事，并把它做好。” 。“做一件事”应该是针对程序本身而言；而不是拿来限制用户或用户的系统组合行为。\nNeovim的Lua插件也是一种程序，它至少在自己的范围内做到了职责单一、组合自如。从某种程度上来说，人本身也是一个可以处理很多事情的系统\u0026ndash;因为其由很多各自注重做一件事的组件组成，人们可以按照自己的需求来完善与 配置出各种途径的Neovim。\nUNIX 哲学的核心不是极简主义，而是用户赋能。用户不应该因为开发者没有预见到他的使用方式就被卡住——他应当始终能够调整自己的工具链，完成自己的目标。 所以我认为即使你的Neovim的配置很复杂，只要在配置的时候能够明确自己的需求，这也不违反UNIX哲学，能被组合、能被替换、能被打断才是 UNIX 精神的关键。\n所以，问题不在插件，而在设计哲学 我相信，大多数人选择 Neovim 就是因为它 既足够轻量，也允许你精细地组合自己的工作流。调试插件、UI 扩展甚至音乐播放功能，只要它们遵守“做一件事”的边界、让用户自己控制组合方式，那它们就完全合理，甚至是 UNIX 哲学最好的继承者。 插件不是 Neovim 的背叛，而是它作为自由编辑器的证明。\n","permalink":"http://localhost:12409/posts/2025_07_29-do_i_need_neovim_plugins/","summary":"\u003cp\u003e今天在尝试寻找一个程序问题的时候，想到了我是不是可以在nvim上添加一个调试的插件，我在搜索的过程中发现一篇有意思的讨论\u003ca href=\"https://www.reddit.com/r/neovim/comments/1cwxlnf/how_many_of_you_use_a_debugger_with_nvim/?show=original\"\n   \n    \n       target=\"_blank\" rel=\"noopener\" \n   \n   class=\"custom-link\"\u003e  \n   how many of you use a debugger with nvim\u003cspan class=\"external-link\"\u003e↗\u003c/span\u003e\u003c/a\u003e\n。题主在讨论中说到了“我在使用 VS Code 时从未设置或使用过调试器，并且一直觉得调试器可能有用却也可能麻烦，所以我现在在考虑是否值得在迁移到 Neovim 后去研究它的调试功能”。\u003c/p\u003e","title":"我是否需要nvim插件"},{"content":" Downmars Enjoy your life! 乱话三千 养了一只叫基金的可爱小猫,平时会写点技术向的东西,有点做饭的小爱好 欢迎大家来访，欢迎互换友链！ 有需要互换友链的可以参考此处，可以在评论区留下你的友链：\nname=\u0026ldquo;Downmars\u0026rdquo;\nurl=\u0026ldquo; https://downmars.github.io/zh/posts/\"↗ logo=\u0026ldquo; https://raw.githubusercontent.com/Downmars/images-PicGo/main/img/miku.jpg\"↗ word=\u0026ldquo;Enjoy your life!\u0026rdquo;\n","permalink":"http://localhost:12409/zh/friends/","summary":"这是我的友链页面","title":"江湖录"},{"content":"","permalink":"http://localhost:12409/zh/thoughts/search/","summary":"thoughts","title":"翻案集"},{"content":"前段时间，我朋友入手了5090（可恶的有钱人），将淘汰下来的主机出手给了我，由于附带的卡是5070 12g，虽然说显存不够大，但是还是想要体验一下N卡的本地模型的乐趣，所以就接手了。于是，我面临了一个问题，我如何将我现有的archlinux配置克隆到新主机上。\n全盘克隆 or 配置文件克隆 现在我面临一个问题，我就是是选择全盘将系统克隆过去，还是只是克隆一些配置文件。前一种方案的好处即全盘克隆可以原封不动实现系统迁徙，并且立即能用；但是存在以下一系列问题，如会携带旧系统大量的垃圾文件，对于不同硬件适配可能产生冲突，就像把旧电脑的主板焊到新机箱使用，维护难度很大。后一种好处有可以在移植的时候思考哪些是我们迁移的时候必要的文件，最小化克隆，对于不同的硬件场景我们也可以很好的进行适配，比如说我们需要将现有的配置移植到arm平台的archlinux，同时不会携带一些旧文件，不适用的驱动等。前一种有如 dd↗ ， clonezilla↗ ， rsync↗ ；后一种我们选择使用 dotfiles↗ 。\n很显然，我们会选择dotfiles作为我们的克隆系统方案，尽管他麻烦一点:)。\n步骤 ","permalink":"http://localhost:12409/posts/2025_12_09-clone_your_archlinux/","summary":"\u003cp\u003e前段时间，我朋友入手了5090（可恶的有钱人），将淘汰下来的主机出手给了我，由于附带的卡是5070 12g，虽然说显存不够大，但是还是想要体验一下N卡的本地模型的乐趣，所以就接手了。于是，我面临了一个问题，我如何将我现有的archlinux配置克隆到新主机上。\u003c/p\u003e","title":"Clone_your_archlinux"},{"content":"我现在的博客部署在 github.io 上，一直想要在个人网站上搭建自己的博客以及部署一些有意思的项目，这次趁双十一购入了服务器与域名，这里做一个简单的记录。\n一台可用的VPS 你可以在任意VPS提供商上购买所需要的服务器，比如说我这边是用的是 RackNerd↗ ，正好赶上双11优惠，花费了70块弄了一个低配的KVM小机子，用作轻量级服务。1vCPU, 1G内存, 20G硬盘空间，3T/月的带宽，虽说配置比较低，但是很适合配置轻量级服务器与学习作用。\n反正就是权衡一下自己的需求，按照性能、稳定性、性价比来选择自己的服务器选型，大家可以自行去网上寻找关于各家VPS的测评。\n我这边购买了RackNerd的服务器遇到了很奇怪的问题。在登录验证邮件中的IP 地址和登录进控制台实际显示的IP 地址不一致，最后是控制台实际显示的IP 地址是正确地址，通过控制台显示的IP能够正常登录。\n一个可用的域名 你同样可以在任意的顶级域名提供商上购买你所中意的域名，我们一般选择.com后缀的域名，具体关于域名选择的讨论可以看 Ask HN: Which domain extension would you choose for your personal site?↗ 。\n我这里选择的是 SpaceShip↗ 上购买我的域名，在哪一家购买域名都可以，基本上就是看价格谁家便宜，我这里购买了 downmars.com 。\nDNS解析 DNS（Domain Name System）域名系统可以告诉网络你的域名关联再哪个服务器上面，我这边选择了 Cloudflare↗ 。它除了帮忙提供DNS解析之外，还能够提供安全流量代理、CDN解析等内容。\n我们再Cloudflare上添加需要管理的域名，选择免费套餐即可，在记录中添加：\nType: A, Name: @, Content: 你的IP地址 Type: CNAME, Name: www, Content: 你的域名\n这两个分别是将访问的域名联系上服务器的IP与将www自动跳转到主域名。 到此，我们设置服务器、域名与DNS解析部分的设置就已经基本完成了，接下来我们就可以在服务器上部署我的所需要的服务了。\n","permalink":"http://localhost:12409/posts/2025_11_16-build_a_personal_website/","summary":"\u003cp\u003e我现在的博客部署在\u003ca href=\"github.io\"\n   \n   \n   class=\"custom-link\"\u003e  \n   github.io\u003c/a\u003e\n上，一直想要在个人网站上搭建自己的博客以及部署一些有意思的项目，这次趁双十一购入了服务器与域名，这里做一个简单的记录。\u003c/p\u003e\n\u003ch2 id=\"一台可用的vps\"\u003e一台可用的VPS\u003c/h2\u003e\n\u003cp\u003e你可以在任意VPS提供商上购买所需要的服务器，比如说我这边是用的是\u003ca href=\"https://www.google.com/url?sa=t\u0026amp;source=web\u0026amp;rct=j\u0026amp;opi=89978449\u0026amp;url=https://www.racknerd.com/\u0026amp;ved=2ahUKEwj9rN3guvaQAxU3m68BHZHhF5kQFnoECD0QAQ\u0026amp;usg=AOvVaw1f3G5tQVYCJRLV5V-s0O-I\"\n   \n    \n       target=\"_blank\" rel=\"noopener\" \n   \n   class=\"custom-link\"\u003e  \n   RackNerd\u003cspan class=\"external-link\"\u003e↗\u003c/span\u003e\u003c/a\u003e\n，正好赶上双11优惠，花费了70块弄了一个低配的KVM小机子，用作轻量级服务。1vCPU, 1G内存, 20G硬盘空间，3T/月的带宽，虽说配置比较低，但是很适合配置轻量级服务器与学习作用。\u003c/p\u003e","title":"2025_11_16 Build_a_personal_website"},{"content":" Downmars Enjoy your life! 乱话三千 养了一只叫基金的可爱小猫,平时会写点技术向的东西,有点做饭的小爱好 欢迎大家来访，欢迎互换友链！ 有需要互换友链的可以参考此处，可以在评论区留下你的友链：\nname=\u0026ldquo;Downmars\u0026rdquo;\nurl=\u0026ldquo; https://downmars.github.io/zh/posts/\"↗ logo=\u0026ldquo; https://raw.githubusercontent.com/Downmars/images-PicGo/main/img/miku.jpg\"↗ word=\u0026ldquo;Enjoy your life!\u0026rdquo;\n","permalink":"http://localhost:12409/zh/friends/","summary":"这是我的友链页面","title":"江湖录"},{"content":"","permalink":"http://localhost:12409/zh/thoughts/search/","summary":"thoughts","title":"翻案集"},{"content":"前段时间，我朋友入手了5090（可恶的有钱人），将淘汰下来的主机出手给了我，由于附带的卡是5070 12g，虽然说显存不够大，但是还是想要体验一下N卡的本地模型的乐趣，所以就接手了。于是，我面临了一个问题，我如何将我现有的archlinux配置克隆到新主机上。\n全盘克隆 or 配置文件克隆 现在我面临一个问题，我就是是选择全盘将系统克隆过去，还是只是克隆一些配置文件。前一种方案的好处即全盘克隆可以原封不动实现系统迁徙，并且立即能用；但是存在以下一系列问题，如会携带旧系统大量的垃圾文件，对于不同硬件适配可能产生冲突，就像把旧电脑的主板焊到新机箱使用，维护难度很大。后一种好处有可以在移植的时候思考哪些是我们迁移的时候必要的文件，最小化克隆，对于不同的硬件场景我们也可以很好的进行适配，比如说我们需要将现有的配置移植到arm平台的archlinux，同时不会携带一些旧文件，不适用的驱动等。前一种有如 dd↗ ， clonezilla↗ ， rsync↗ ；后一种我们选择使用 dotfiles↗ 。\n很显然，我们会选择dotfiles作为我们的克隆系统方案，尽管他麻烦一点:)。\n步骤 ","permalink":"http://localhost:12409/posts/2025_12_09-clone_your_archlinux/","summary":"\u003cp\u003e前段时间，我朋友入手了5090（可恶的有钱人），将淘汰下来的主机出手给了我，由于附带的卡是5070 12g，虽然说显存不够大，但是还是想要体验一下N卡的本地模型的乐趣，所以就接手了。于是，我面临了一个问题，我如何将我现有的archlinux配置克隆到新主机上。\u003c/p\u003e","title":"Clone_your_archlinux"},{"content":"我现在的博客部署在 github.io 上，一直想要在个人网站上搭建自己的博客以及部署一些有意思的项目，这次趁双十一购入了服务器与域名，这里做一个简单的记录。\n一台可用的VPS 你可以在任意VPS提供商上购买所需要的服务器，比如说我这边是用的是 RackNerd↗ ，正好赶上双11优惠，花费了70块弄了一个低配的KVM小机子，用作轻量级服务。1vCPU, 1G内存, 20G硬盘空间，3T/月的带宽，虽说配置比较低，但是很适合配置轻量级服务器与学习作用。\n反正就是权衡一下自己的需求，按照性能、稳定性、性价比来选择自己的服务器选型，大家可以自行去网上寻找关于各家VPS的测评。\n我这边购买了RackNerd的服务器遇到了很奇怪的问题。在登录验证邮件中的IP 地址和登录进控制台实际显示的IP 地址不一致，最后是控制台实际显示的IP 地址是正确地址，通过控制台显示的IP能够正常登录。\n一个可用的域名 你同样可以在任意的顶级域名提供商上购买你所中意的域名，我们一般选择.com后缀的域名，具体关于域名选择的讨论可以看 Ask HN: Which domain extension would you choose for your personal site?↗ 。\n我这里选择的是 SpaceShip↗ 上购买我的域名，在哪一家购买域名都可以，基本上就是看价格谁家便宜，我这里购买了 downmars.com 。\nDNS解析 DNS（Domain Name System）域名系统可以告诉网络你的域名关联再哪个服务器上面，我这边选择了 Cloudflare↗ 。它除了帮忙提供DNS解析之外，还能够提供安全流量代理、CDN解析等内容。\n我们再Cloudflare上添加需要管理的域名，选择免费套餐即可，在记录中添加：\nType: A, Name: @, Content: 你的IP地址 Type: CNAME, Name: www, Content: 你的域名\n这两个分别是将访问的域名联系上服务器的IP与将www自动跳转到主域名。 到此，我们设置服务器、域名与DNS解析部分的设置就已经基本完成了，接下来我们就可以在服务器上部署我的所需要的服务了。\n","permalink":"http://localhost:12409/posts/2025_11_16-build_a_personal_website/","summary":"\u003cp\u003e我现在的博客部署在\u003ca href=\"github.io\"\n   \n   \n   class=\"custom-link\"\u003e  \n   github.io\u003c/a\u003e\n上，一直想要在个人网站上搭建自己的博客以及部署一些有意思的项目，这次趁双十一购入了服务器与域名，这里做一个简单的记录。\u003c/p\u003e\n\u003ch2 id=\"一台可用的vps\"\u003e一台可用的VPS\u003c/h2\u003e\n\u003cp\u003e你可以在任意VPS提供商上购买所需要的服务器，比如说我这边是用的是\u003ca href=\"https://www.google.com/url?sa=t\u0026amp;source=web\u0026amp;rct=j\u0026amp;opi=89978449\u0026amp;url=https://www.racknerd.com/\u0026amp;ved=2ahUKEwj9rN3guvaQAxU3m68BHZHhF5kQFnoECD0QAQ\u0026amp;usg=AOvVaw1f3G5tQVYCJRLV5V-s0O-I\"\n   \n    \n       target=\"_blank\" rel=\"noopener\" \n   \n   class=\"custom-link\"\u003e  \n   RackNerd\u003cspan class=\"external-link\"\u003e↗\u003c/span\u003e\u003c/a\u003e\n，正好赶上双11优惠，花费了70块弄了一个低配的KVM小机子，用作轻量级服务。1vCPU, 1G内存, 20G硬盘空间，3T/月的带宽，虽说配置比较低，但是很适合配置轻量级服务器与学习作用。\u003c/p\u003e","title":"2025_11_16 Build_a_personal_website"},{"content":" Downmars Enjoy your life! 乱话三千 养了一只叫基金的可爱小猫,平时会写点技术向的东西,有点做饭的小爱好 欢迎大家来访，欢迎互换友链！ 有需要互换友链的可以参考此处，可以在评论区留下你的友链：\nname=\u0026ldquo;Downmars\u0026rdquo;\nurl=\u0026ldquo; https://downmars.github.io/zh/posts/\"↗ logo=\u0026ldquo; https://raw.githubusercontent.com/Downmars/images-PicGo/main/img/miku.jpg\"↗ word=\u0026ldquo;Enjoy your life!\u0026rdquo;\n","permalink":"http://localhost:12409/zh/friends/","summary":"这是我的友链页面","title":"江湖录"},{"content":"","permalink":"http://localhost:12409/zh/thoughts/search/","summary":"thoughts","title":"翻案集"}]